<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Live Anthropics Data Engineering for Fine-Tuning</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: 'Orbitron', sans-serif;
            background-color: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: radial-gradient(circle, rgba(0, 0, 0, 1) 0%, rgba(23, 32, 42, 1) 100%);
            overflow-y: auto; /* Enable vertical scrolling */
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 0 20px;
            flex-grow: 1;
            box-sizing: border-box;
        }
        h2 {
            font-size: 2rem;
            margin: 80px 0 20px 0;
            text-align: center;
        }
        .explore-button {
            background-color: #0f0;
            color: #000;
            border: 2px solid #0f0;
            border-radius: 20px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 0 10px #0f0, 0 0 20px #0f0, 0 0 30px #0f0;
            transition: all 0.3s ease-in-out;
            text-decoration: none;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            animation: pulse 2s infinite;
        }
        .explore-button:hover {
            background-color: #000;
            color: #0f0;
            box-shadow: 0 0 20px #0f0, 0 0 40px #0f0, 0 0 60px #0f0;
        }
        @keyframes pulse {
            0% {
                transform: translateX(-50%) scale(1);
                box-shadow: 0 0 10px #0f0, 0 0 20px #0f0, 0 0 30px #0f0;
            }
            50% {
                transform: translateX(-50%) scale(1.1);
                box-shadow: 0 0 20px #0f0, 0 0 40px #0f0, 0 0 60px #0f0;
            }
            100% {
                transform: translateX(-50%) scale(1);
                box-shadow: 0 0 10px #0f0, 0 0 20px #0f0, 0 0 30px #0f0;
            }
        }
        .content-wrapper {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 1200px; /* Limit max width for better readability on large screens */
            height: auto; /* Allow content to grow with content */
            flex-grow: 1;
            flex-wrap: wrap; /* Wrap items for smaller screens */
            margin-top: 20px;
        }
        .content-box {
            width: 48%;
            min-width: 300px; /* Ensure a minimum width */
            margin-bottom: 20px;
            overflow: hidden;
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            background-color: rgba(15, 15, 15, 0.8);
            box-sizing: border-box;
        }
        #process-explanation {
            max-height: 70vh; /* Limit height for better scrollability */
            overflow-y: auto; /* Scrollbar for large content */
            padding-right: 10px;
            animation: fadeInSlideUp 1.5s ease-in-out; /* Added animation effect */
        }
        #responses {
            max-height: 70vh; /* Limit height for better scrollability */
            overflow: hidden;
            position: relative;
            padding: 10px 20px; /* Added padding on left and right corners */
        }
        .marquee-container {
            position: absolute;
            bottom: 0;
            width: calc(100% - 40px); /* Adjusted width considering padding */
            display: flex;
            flex-direction: column;
            gap: 40px; /* Spacing between question-answer blocks */
        }
        .response {
            width: 100%;
            opacity: 1;
            word-wrap: break-word;
        }
        .question, .answer {
            margin-bottom: 10px;
            font-size: 18px; /* Adjusted to previous size */
        }
        .question strong {
            color: #ff0;
        }
        .answer strong {
            color: #0ff;
        }
        ::-webkit-scrollbar {
            width: 5px;
        }
        ::-webkit-scrollbar-track {
            background: #000;
        }
        ::-webkit-scrollbar-thumb {
            background: #0f0;
        }
        .step-box {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #0f0;
            border-radius: 10px;
            background-color: rgba(15, 15, 15, 0.8);
            color: #0f0;
            text-align: left;
        }
        @keyframes fadeInSlideUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }
        @media (max-width: 768px) {
            .content-wrapper {
                flex-direction: column;
                height: auto;
            }
            .content-box {
                width: 100%;
                margin-bottom: 20px;
            }
            #process-explanation, #responses {
                max-height: 60vh; /* Adjusted height for smaller screens */
            }
        }
    </style>
</head>
<body>
    <button class="explore-button" onclick="window.location='show_case.html'">ðŸš€ Explore the Open Source Autonomous Intelligence for Electronics ðŸš€</button>

    <div class="container">
        <h2>COMING SOON: Live Autonomous Intelligence Center for the Community</h2>
        <div class="content-wrapper">
            <!-- PDF Processing Steps -->
            <div class="content-box" id="process-explanation">
                <h3 class="fade-in-slide-up">Our fine-tuning process</h3>
                <div class="step-box">
                    <strong>Step 1:</strong> First, we collect the required PDF files that contain detailed data on electronic components. These files are sourced from various locations to provide comprehensive information needed for fine-tuning our model.
                </div>
                <div class="step-box">
                    <strong>Step 2:</strong> Next, we manually write prompts and apply them to the collected PDF files using a specialized script. This script automates the generation of training data by processing the files according to our prompts, streamlining the preparation process. The script outputs the data in JSON format.
                </div>
                <div class="step-box">
                    <strong>Step 3:</strong> The generated JSON files are then reformatted to ensure that the data structure adheres to the required format for our model to process effectively.
                </div>
                <div class="step-box">
                    <strong>Step 4:</strong> After reformatting, these JSON files are converted into JSONL format. JSONL is particularly advantageous for processing large datasets efficiently, as it allows each record to be managed independently in a sequential, line-by-line manner, which is essential for fine-tuning our model.
                </div>
                <div class="step-box">
                    <strong>Step 5:</strong> We then consolidate all the JSONL files into a single JSONL file, which is prepared for use in the fine-tuning process.
                </div>
                <div class="step-box">
                    <strong>Step 6:</strong> Finally, the combined JSONL file is uploaded, initiating the fine-tuning process for our model.
                </div>
            </div>

            <!-- Questions and Responses -->
            <div class="content-box" id="responses">
                <div class="marquee-container">
                    <!-- Responses will be dynamically added here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Script for continuous marquee of questions and responses -->
    <script>
        $(document).ready(function() {
            const questionsAndAnswers = [
                {
                    "question": "What are the methods RISC-V architecture uses to connect with external peripherals like sensors and actuators?",
                    "answer": "RISC-V architecture connects with external peripherals using several methods: 1. GPIO (General Purpose Input/Output): RISC-V systems typically include GPIO ports that allow direct connection with sensors and actuators for digital signals. Each pin can be configured as either an input or output.2.I2C (Inter-Integrated Circuit): This is a multi-master serial computer bus that allows multiple slave devices to be controlled by a single master. RISC-V SoCs can integrate I2C controllers to communicate with various sensors and low-speed peripherals. 3.SPI (Serial Peripheral Interface): SPI is another serial communication interface that enables RISC-V processors to communicate with high-speed peripherals such as sensors and memory devices. 4.UART (Universal Asynchronous Receiver-Transmitter): RISC-V SoCs often include UART interfaces for serial communication with devices like GPS modules, modems, and other peripherals. 5. PCIe (Peripheral Component Interconnect Express): For high-speed connections, RISC-V can use PCIe to connect with GPUs, FPGAs, and other high-performance peripherals. 6. CAN (Controller Area Network): Useful in automotive applications, RISC-V processors can interface with CAN buses to communicate with various automotive sensors and actuators. 7.DMA (Direct Memory Access): Some RISC-V implementations support DMA controllers to facilitate efficient data transfer between peripherals and memory without CPU intervention, improving performance.8.Custom Interfaces: Developers can create custom interfaces for specific peripherals, leveraging the flexible nature of the RISC-V architecture to suit unique application requirements."
                },
                {
                    "question": "How does the RISC-V architecture connect with external peripherals like NVDLA?",
                    "answer": "The RISC-V architecture connects with external peripherals, such as NVDLA, through a combination of buses and interfaces. In the integration described, the Front Bus connects to the Data Buffer Block (DBB) interface of NVDLA. A TileLink switch serves as the Peripheral Bus, which connects various slave devices and maps them to memory regions. The CSB (Control and Status Bus) interface of NVDLA is connected to the Peripheral Bus, allowing the RISC-V processor to access memory-mapped registers. Additionally, a Platform-level Interrupt Controller (PLIC) routes interrupt signals from NVDLA and other devices to the CPU cores, facilitating communication and control. This integration is further enhanced by creating a wrapper layer that translates between the TileLink protocol used by Rocket Chip and the ARM APB and AXI protocols used by NVDLA."
                },
                {
                    "question": "What role does the NVDLA Wrapper play in the integration with RISC-V?",
                    "answer": "The NVDLA Wrapper plays a crucial role in the integration of NVDLA with the RISC-V architecture by facilitating communication between different bus protocols. Since Rocket Chip utilizes the TileLink bus protocol for on-chip communication, the wrapper converts bus transactions between the NVDLA, which employs ARM APB and AXI bus protocols, and the Rocket Chip SoC. This ensures compatibility and enables seamless interaction between the RISC-V processor and the NVDLA, allowing the processor to issue commands and receive data from the NVDLA without protocol mismatches."
                },
                {
                    "question": "How does RISC-V handle exceptions and interrupts?",
                    "answer": "RISC-V handles exceptions and interrupts through its trap mechanism. When an interrupt or exception occurs, the CPU stops executing the current instruction stream and jumps to a predefined trap handler address. The handler then determines the cause of the interrupt or exception, processes it, and optionally resumes the interrupted task."
                },
                {
                    "question": "What are the benefits of using RISC-V for embedded systems?",
                    "answer": "RISC-V offers several benefits for embedded systems: its open standard allows for customization without licensing fees, it provides a small and efficient instruction set ideal for low-power devices, and it has strong community support with a growing ecosystem of tools and libraries."
                },
                {
                    "question": "Can RISC-V processors support multiple operating systems?",
                    "answer": "Yes, RISC-V processors can support multiple operating systems. The architecture is designed to be flexible and scalable, making it suitable for a wide range of operating systems, from small real-time operating systems (RTOS) to large, complex systems like Linux."
                },
                {
                    "question": "What is the role of the CSR (Control and Status Registers) in RISC-V?",
                    "answer": "In RISC-V, Control and Status Registers (CSRs) play a crucial role in managing the state of the processor. CSRs are used for controlling various aspects of the CPU operation, including managing interrupts, exceptions, and other critical processor functions."
                },
                {
                    "question": "How does RISC-V support hardware virtualization?",
                    "answer": "RISC-V supports hardware virtualization through its hypervisor extension, which allows the CPU to run multiple operating systems simultaneously. This extension provides the necessary instructions and control mechanisms to isolate and manage virtual machines efficiently."
                },
                {
                    "question": "What are the primary use cases for RISC-V in AI and machine learning?",
                    "answer": "RISC-V is increasingly being used in AI and machine learning applications due to its flexibility and customizability. It allows developers to add custom instructions for AI accelerators, optimize data paths, and implement specialized processing units tailored for neural networks and other AI workloads."
                },
                {
                    "question": "What advantages does RISC-V offer over proprietary architectures?",
                    "answer": "RISC-V offers several advantages over proprietary architectures, including the freedom to customize and extend the instruction set, no licensing fees, and the ability to collaborate within a growing open-source community. This makes it ideal for both academic research and commercial applications."
                },
                {
                    "question": "How can RISC-V be used in IoT applications?",
                    "answer": "RISC-V is well-suited for IoT applications due to its low-power design, scalability, and support for a wide range of peripherals. Developers can customize RISC-V cores to include specific features like enhanced security, real-time processing, and efficient communication protocols required for IoT devices."
                },
                {
                    "question": "What is the significance of the RISC-V vector extension?",
                    "answer": "The RISC-V vector extension (RVV) allows processors to handle data-parallel workloads efficiently, which is critical for applications such as scientific computing, graphics processing, and machine learning. RVV enables the execution of the same operation on multiple data points simultaneously, improving performance in these areas."
                },
                {
                    "question": "How does the RISC-V architecture handle memory management?",
                    "answer": "RISC-V handles memory management through its Memory Management Unit (MMU), which supports virtual memory, paging, and protection mechanisms. This allows for efficient use of memory in complex applications, such as operating systems, by providing features like address translation and access control."
                },
                {
                    "question": "What role does the RISC-V foundation play in the ecosystem?",
                    "answer": "The RISC-V Foundation plays a crucial role in maintaining and promoting the RISC-V instruction set architecture. It oversees the development of the standard, ensures compatibility across implementations, and fosters a community of developers and companies contributing to the ecosystem."
                },
                {
                    "question": "How can RISC-V be customized for specific applications?",
                    "answer": "RISC-V can be customized for specific applications by adding custom instructions, modifying the core to include application-specific accelerators, or even developing entirely new cores tailored to particular workloads. This flexibility makes RISC-V suitable for a wide range of industries, from consumer electronics to high-performance computing."
                },
                {
                    "question": "What is the role of RISC-V in the open-source hardware movement?",
                    "answer": "RISC-V plays a pivotal role in the open-source hardware movement by providing an open and royalty-free instruction set that encourages innovation and collaboration. This has led to the development of a wide range of open-source RISC-V cores, tools, and software that are accessible to anyone."
                },
                {
                    "question": "How does RISC-V handle floating-point operations?",
                    "answer": "RISC-V handles floating-point operations through its optional floating-point extensions, which provide instructions for single- and double-precision arithmetic. These extensions are designed to be efficient and are used in applications that require high numerical accuracy, such as scientific computing and signal processing."
                },
                {
                    "question": "What are some challenges of adopting RISC-V in commercial products?",
                    "answer": "Adopting RISC-V in commercial products can present challenges such as the need for ecosystem maturity, including the availability of robust development tools, software support, and skilled engineers. However, the growing community and increasing adoption are rapidly addressing these challenges."
                },
                {
                    "question": "Can RISC-V be used for high-performance computing (HPC)?",
                    "answer": "Yes, RISC-V can be used for high-performance computing (HPC). With the addition of extensions like vector processing and the ability to design custom accelerators, RISC-V is becoming increasingly viable for HPC applications, providing a flexible and scalable alternative to traditional architectures."
                },
                {
                    "question": "How does the RISC-V architecture ensure security?",
                    "answer": "RISC-V ensures security through various approaches, including hardware-enforced privilege levels, support for secure boot processes, and optional cryptographic extensions. These features help protect against common attack vectors and allow for the implementation of secure systems in both consumer and industrial applications."
                }
            ];

            function startMarquee() {
                const container = $('.marquee-container');
                container.empty();  // Clear existing content

                questionsAndAnswers.forEach((qa) => {
                    const responseHtml = `
                        <div class="response">
                            <div class="question"><strong>User:</strong> ${qa.question}</div>
                            <div class="answer"><strong>Response:</strong> ${qa.answer}</div>
                        </div>`;
                    container.append(responseHtml);
                });

                const totalHeight = container[0].scrollHeight;
                const containerHeight = $('#responses').height();
                
                function animateMarquee() {
                    container.css('top', containerHeight); // Start below the container
                    container.animate({ top: -totalHeight }, totalHeight * 40, 'linear', function() {
                        animateMarquee(); // Repeat infinitely without restart
                    });
                }

                animateMarquee();
            }

            startMarquee();
        });
    </script>
</body>
</html>
